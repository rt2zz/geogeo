{
  "name": "redux-persist",
  "version": "0.4.5",
  "description": "persist and rehydrate redux stores",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha --compilers js:babel/register --recursive",
    "clean": "rimraf lib dist",
    "build": "babel src --out-dir lib",
    "build:watch": "watch 'npm run build' ./src",
    "prepublish": "npm run clean && npm run build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rt2zz/redux-persist.git"
  },
  "homepage": "https://github.com/rt2zz/redux-persist",
  "keywords": [
    "redux",
    "redux-middleware",
    "react-native",
    "flux",
    "localstorage",
    "redux-persist",
    "redux-storage",
    "redux-rehydrate"
  ],
  "author": {
    "name": "rt2zz",
    "email": "zack@root-two.com"
  },
  "license": "MIT",
  "dependencies": {
    "lodash.foreach": "^3.0.0"
  },
  "devDependencies": {
    "babel": "^5.8.21",
    "babel-core": "^5.8.22",
    "expect": "^1.9.0",
    "mocha": "^2.2.5",
    "redux": "^1.0.1",
    "rimraf": "^2.4.2"
  },
  "readme": "# Redux Persist\nPersist a redux store.\n\n* Operates on a per reducer basis\n* Performant out of the box (uses a time iterator and operates on state partials)\n* Supports localStorage, react-native AsyncStorage, or any conforming storage api\n* ImmutableJS support with [redux-persist-immutable](https://github.com/rt2zz/redux-persist-immutable)\n\n**NOTE** a lot of changes in 0.4.0. Please submit an issue if you have any trouble migrating.\n\nImplementing rehydration is very application specific. Check out some [recipes](https://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md).\n\n## Basic Usage\nBasic usage requires adding three lines to a traditional redux application:\n```js\nimport { persistStore, autoRehydrate } from 'redux-persist'\nconst store = compose(autoRehydrate(), createStore)(reducer)\npersistStore(store)\n```\nFor more complex rehydration, like restoring immutable data, add a handler to your reducer:\n```js\nimport {REHYDRATE} from 'redux-persist/constants'\n//...\ncase REHYDRATE:\n  if(action.key === 'myReducer'){\n    //restore immutable data\n    let someList = Immutable.List(action.payload.someList)\n    return {...state, ...action.payload, someList}\n  }\n  return state\n```\nYou may also need to configure the persistence layer, or take action after rehydration has completed:\n```js\npersistStore(store, {blacklist: ['someTransientReducer']}, () => {\n  console.log('rehydration complete')\n})\n```\nAnd if things get out of wack, just purge the storage\n```js\npersistStore(store, config, callback).purge(['someReducer']) //or .purgeAll()\n```\n\n## Rationale\nThe core idea behind redux-persist is to provide performant persistence and rehydration methods. Additionally redux-persist is designed to minimize complexity by knowing as little as possible about your application and state schema. All of this is achieved through the `persistStore` method with no additional configuration.\n\nHowever because persistence is such a common problem, and because applications tend to have similar but slightly different persistence rules, redux-persist also provides several convenience methods (e.g. `autoRehydrate`) and configuration options (e.g. `config.transforms`). Do not let these scare you away, they are really just \"shortcuts\" for achieving various functionality.\n\nConceptually redux-persist encourages you to think on a per-reducer basis. This greatly simplifies the mental model (no filters or selectors!) and means that if you change your reducer schema, you will not need to mirror those changes in your persistence configuration. If you have some transient state that should not be persisted, it is probably best to split that state into it's own reducer which can then be added to the persistStore blacklist.\n\n## API\n- `persistStore(store, [config, callback])`\n  - **store** *redux store* The store to be persisted.\n  - **config** *object*\n    - **blacklist** *array* keys (read: reducers) to ignore\n    - **actionCreator** *action creator* The rehydrate action creator. absent will use a default action creator which returns: `{ key, payload, type: 'REHYDRATE'}`\n    - **storage** *object* An object with the following methods implemented `setItem(key, string, cb)` `getItem(key, cb)` `removeItem(key, cb)`\n    - **transforms** *array* transforms to be applied during storage and during rehydration.\n  - **callback** *function* Will be called after rehydration is finished.\n\n- `autoRehydrate`\n  - This is a store enhancer that will automatically shallow merge the persisted state for each key. Additionally it queues any actions that are dispatched before rehydration is complete, and fires them after rehydration is finished.\n\n- `.purge(keys)`\n  - **keys** *array* An array of keys to be purged from local storage. (this method is available on the return value of persistStore)\n\n- `.purgeAll()`\n  -  Purges all keys. (this method is available on the return value of persistStore)\n\n- `constants`\n  - `import constants from 'redux-persist/constants'`. This includes rehydration action types, and other relevant constants.\n\n## Customization\n#### Immutable Support\nThe [`redux-persist-immutable`](https://github.com/rt2zz/redux-persist-immutable) transform will serialize immutable objects using and automatically restore them.\n```js\nimport reduxPersistImmutable from 'redux-persist-immutable'\npersistStore(store, {transforms: [reduxPersistImmutable]})\n\n// It works on nested and mixed immutable objects as well:\nstate = {\n  reducerA: Map(),\n  reducerB: {a: 1, b: Map()},\n  reducerC: {a: Map({aa: 'foo', bb: List([1, 2])})}\n}\n```\n\n#### Custom Action Creator\nCustom action creators are one way to take action during rehydration, such as validating access tokens.\n```js\nimport { REHYDRATE } from 'redux-persist/constants' // be sure to use the provided action type constants if using autoRehydrate\nconst rehydrateAction = (key, data) => {\n  if(key === 'auth'){\n    validateToken(data.token)\n  }\n  return {\n    type: REHYDRATE,\n    key: key,\n    payload: data\n  }\n}\npersistStore(store, {actionCreator: rehydrateAction})\n```\n#### Without Auto Rehydration\nThe heavy lifting in redux-persist is in restoration. `autoRehydrate` is purely provided as a convenience. In a large application, or one with atypical reducer composition, auto rehydration may not be convenient. In this case, simply omit autoRehydrate. Rehydration actions will still be fired by `persistStore`, and you can then either write a custom rehydration function, or handle your rehydration on a reducer by reducer basis.\n\n## Storage Backends\n**localStorage** (default), react-native **AsyncStorage**, or a conforming **custom** storage api. Custom storage API should be an object with the following methods: `setItem` `getItem` `removeItem` `getAllKeys` each with the function signature as found in [react-native AsyncStorage](http://facebook.github.io/react-native/docs/asyncstorage.html#content).\n\n\n#### React-Native Example\n```js\nvar { AsyncStorage } = require('react-native')\nvar { persistStore } = require('redux-persist')\n\npersistStore(store, {storage: AsyncStorage}, () => {\n  console.log('rehydration complete')\n})\n```\n\n## Auto Rehydrate Notes\nAuto rehydrate is a higher order reducer that automatically rehydrates state.\n\nWhile auto rehydration works out of the box, individual reducers can opt in to handling their own rehydration, allowing for more complex operations like applying data transforms, or doing cache invalidation. Simply define a handler for the rehydrate action in your reducer, and if the state is mutated, auto rehydrate will skip that key.\n\nautoRehydrate will automatically queue any actions dispatched before rehydration is complete, and fire them immediately after rehydration is complete. This is to avoid the tricky problem of rehydration over-writing earlier state changes.\n\n```js\ncase REHYDRATE:\n  //make sure to check the key that is currently being rehydrated!\n  if(action.key === 'myReducer'){\n    //delete transient data\n    delete action.payload.someTransientData\n\n    //increment a counter\n    var rehydrationCount = action.payload.rehydrationCount + 1\n\n    //invalidate a cache\n    var someCachedData = Date.now()-10000 > action.payload.someCachedData.time ? null : action.payload.someCachedData\n\n    return {...state, rehydrationCount, someCachedData}\n  }\n  else return state\n\n```\n\n## Implementation Notes\nFor performance  \n**During Rehydration** getItem calls are invoked once per key using setImmediate.  \n**During Storage** setItem calls are invoked only on keys whose state has changed, using a time iterator one key every 33 ms (i.e. 30fps)  \n",
  "readmeFilename": "README.md",
  "gitHead": "6ccbabed16beed80fc7951bc7d528c7b01e1f0b0",
  "bugs": {
    "url": "https://github.com/rt2zz/redux-persist/issues"
  },
  "_id": "redux-persist@0.4.5",
  "_shasum": "a2d2b06000c5978a78998763f906a2504ce22725",
  "_from": "redux-persist@>=0.4.4 <0.5.0"
}
