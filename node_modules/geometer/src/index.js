import invariant from 'invariant'
import {encode, decode} from './hash'

export function createGeometer(db, options){
  return new geometer(db, options)
}

function geometer(db, options){
  invariant(Number.isInteger(options.precision), 'options.precision must be an integer')
  //@TODO options.indexRef

  this._precision = options.precision

  if(options.geo === true){
    this._normalizeTuple = (tuple) => {
      return [100*tuple[0]/90, 100*tuple[1]/180]
    }
    this._denormalizeTuple = (tuple) => {
      return [90*tuple[0]/100, 180*tuple[1]/100]
    }
  }
  else{
    this._normalizeTuple = (tuple) => tuple
    this._denormaizeTuple = (tuple) => tuple
  }

  this.db = db
}

geometer.prototype.addPoint = function(ref, tuple, z, data, cb){
  data = data || ' '
  let pointKey = createPointKey(ref, this._normalizeTuple(tuple), z, this._precision)
  let refKey = createRefKey(ref)

  this.db.put(refKey, pointKey, () => {
    //@TODO handle error?
  })
  this.db.put(pointKey, data, cb)
}

geometer.prototype.removePointByRef = function(ref, cb){
  this.db.del(createRefKey(ref), cb)
}

geometer.prototype.getPointByRef = function(ref, cb){
  this.db.get(createRefKey(ref), (err, pointKey) => {
    if(err){ cb(err); return; }
    this.db.get(pointKey, (err, data) => {
      cb(err, this.kvToPoint(pointKey, data))
    })
  })
}

geometer.prototype.kvToPoint = function(key, value){
  let keyParts = key.split('~')
  return {
    tuple: this._denormaizeTuple(decode(keyParts[1])),
    z: keyParts[2],
    ref: keyParts[3],
    data: value,
  }
}

geometer.prototype.createSearchStream = function (pos, options) {
  var self = this
  if (!options) options = {}

  var centerHash = encode(this._normalizeTuple(pos), this._precision)

  var db = this.db
  var found = []
  var outer = shutup(through())

  var hardLimit = options.hardResultLimit || Infinity
  var softLimit = options.softResultLimit || Infinity
  var maxRing = options.maxRing || 3
  var initialRing = options.initialRing || 1

  function read (innermostRing, outermostRing) {
    var streams = []
    var innerEndCount = 0

    var hashes = self.getRingHashes(pos, innermostRing, outermostRing)

    //stream each hash into the outer stream
    hashes.forEach(function(hash){
      var _opts = { gte: hash, lte: key+'~', values: false, old: false }
      var dbStream = db.createReadStream(_opts)
      streams.push(dbStream)
      var inner = through(write, end)

      function write (str) {
        if (found.indexOf(str) != -1) return
        found.push(str)
        inner.queue(str)
        if (found.length === hardLimit){
          end()
        }
      }

      function end () {
        innerEndCount++

        //if we have hit hard limit, destroy active streams and return
        if(found.length >= hardLimit){
          streams.forEach(function(stream){ stream.destroy() })
          outer.end()
          return
        }

        //otherwise do nothing until all resolution peer streams have finished
        if(innerEndCount === hashes.length){
          if(outermostRing === maxRing || found.length >= softLimit){
            outer.end()
          }
          else {
            read(outermostRing+1, outermostRing+1)
          }
        }
      }
      dbStream.pipe(inner).pipe(outer, { end: false })
      outer.on('end', dbStream.destroy.bind(dbStream))
    })
  }

  process.nextTick(function () {
    read(0, initialRing)
  })

  return outer
}

geometer.prototype.getRingHashes = function(tuple, innermostRing, outermostRing){
  var hashes = []
  for(ring = innermostRing; ring <= outermostRing; ring++){
    if(ring === 0){
      hashes.push(encode(tuple, this._precision)) //@TODO fix
    }
    for(j = 0; j < ring*2; j++){
      //start at four corners and travel across each direction (NESW)
      var tupleNE = [tuple[0]+unit*ring, tuple[1]+unit*ring - unit*j]
      var tupleSE = [tuple[0]+unit*ring - unit*j, tuple[1]-unit*ring]
      var tupleSW = [tuple[0]-unit*ring, tuple[1]-unit*ring + unit*j]
      var tupleNW = [tuple[0]-unit*ring + unit*j, tuple[1]+unit*ring]
      hashes = hashes.concat([encode(tupleNE, this._precision), encode(tupleSE, this._precision), encode(tupleSW, this._precision), encode(tupleNW, this._precision)])
    }
  }
  return hashes
}

geometer.prototype.stream = function(tuple, opts){
  var normalTuple = this._normalizeTuple(tuple)

  var kvToPoint = this.kvToPoint
  var kvToPointStream = through(function({key, value}){
    this.queue(kvToPoint(key, value))
  })
  var resultStream = this.createSearchStream(normalTuple, opts).pipe(kvToPointStream)

  resultStream.toArray = function(cb){
    resultStream.pipe(es.writeArray(function(err, results){
      //@TODO sorting
      // var sorted = results.sort(function(a, b){
      //   if(a.distance < b.distance) return -1
      //   if(a.distance > b.distance) return 1
      //   return 0
      // })
      cb(null, results)
    }))
  }

  return resultStream
}

function createPointKey(ref, normalAbTuple, z, precision){
  return ['p', encode(normalAbTuple, precision), z, ref].join('~')
}

function createRefKey(ref){
  return ['r', ref].join('~')
}
