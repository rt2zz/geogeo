import geo from './geo'
import {encode, decode} from './hash'

export function createGeometer(db, options){
  return new geometer(db, options)
}

function geometer(db, options){
  if(options.geo === true){
    this._normalizeTuple = (tuple) => {
      return [100*tuple[0]/90, 100*tuple[1]/180]
    }
    this._denormalizeTuple = (tuple) => {
      return [90*tuple[0]/100, 180*tuple[1]/100]
    }
  }
  else{
    this._normalizeTuple = (tuple) => tuple
    this._denormaizeTuple = (tuple) => tuple
  }

  this.db = db
}

geometer.prototype.addPoint = function(ref, tuple, z, data, cb){
  data = data || ' '
  let pointKey = createPointKey(ref, this._normalizeTuple(tuple), z)
  let refKey = createRefKey(ref)

  this.db.put(refKey, pointKey, () => {
    //@TODO handle error?
  })
  this.db.put(pointKey, data, cb)
}

geometer.prototype.removePointByRef = function(ref, cb){
  this.db.del(createRefKey(ref), cb)
}

geometer.prototype.getPointByRef = function(ref, cb){
  this.db.get(createRefKey(ref), (err, pointKey) => {
    if(err){ cb(err); return; }
    this.db.get(pointKey, (err, data) => {
      cb(err, this.kvToPoint(pointKey, data))
    })
  })
}

geometer.prototype.kvToPoint = function(key, value){
  let keyParts = key.split('~')
  return {
    tuple: this._denormaizeTuple(decode(keyParts[1])),
    z: keyParts[2],
    ref: keyParts[3],
    data: value,
  }
}

GeoTrie.prototype.createSearchStream = function (pos, opts) {
  if (!opts) opts = {}

  var hash = encode(this._normalizeTuple(pos))

  var db = this.db
  var found = []
  var outer = shutup(through())

  //@TODO allow user to specify radius in meters and traslate to min/max resolution https://docs.google.com/spreadsheets/d/1IKnQVSg5xkwVQ8SBuznJhD2N9BkUxMOrC1qf-r5ppMU/edit#gid=0
  // var hardLimit = typeof opts.hardLimit != 'undefined'? opts.hardLimit : Infinity
  // var softLimit = typeof opts.softLimit != 'undefined'? opts.softLimit : Infinity
  // var maxResolution = typeof opts.maxResolution != 'undefined'? opts.maxResolution : hash.length
  // var minResolution = typeof opts.minResolution != 'undefined'? opts.minResolution : 0
  //
  // var resolution = maxResolution
  //
  // function read (resolution) {
  //   var key = hash.substr(0, resolution)
  //   var hashes = [key]
  //   var keystreams = []
  //   var innerEndCount = 0
  //
  //   var centroid = geo.decode(key)
  //   var deltas = { lat: pos.lat - centroid.lat, lon: pos.lon - centroid.lon}
  //   var neighbors = []
  //   if(Math.abs(deltas.lat) > boxwidth(resolution).lat/2/2){
  //     neighbors.push(deltas.lat < 0 ? 's' : 'n')
  //   }
  //   if(Math.abs(deltas.lon) < boxwidth(resolution).lon/2/2){
  //     neighbors.push(deltas.lon < 0 ? 'w' : 'e')
  //     if(neighbors.length === 2) neighbors.push(neighbors[0]+neighbors[1])
  //   }
  //   neighbors.forEach(function(neighbor){
  //     hashes.push(geo.getNeighbor(neighbor, centroid, resolution))
  //   })
  //
  //   //string up a key stream for each hash into the outer stream
  //   hashes.forEach(function(hash){
  //     var _opts = { gte: hash, lte: key+'~', values: false, old: false }
  //     var ks = db.createReadStream(_opts)
  //     keystreams.push(ks)
  //     var inner = through(write, end)
  //
  //     function write (str) {
  //       if (found.indexOf(str) != -1) return
  //       found.push(str)
  //       inner.queue(str)
  //       if (found.length === hardLimit){
  //         end()
  //       }
  //     }
  //
  //     function end () {
  //       innerEndCount++
  //
  //       //if we have hit hard limit, destroy active streams and return
  //       if(found.length >= hardLimit){
  //         keystreams.forEach(function(keystream){ keystream.destroy() })
  //         outer.end()
  //         return
  //       }
  //
  //       //otherwise do nothing until all resolution peer streams have finished
  //       if(innerEndCount === hashes.length){
  //         if(resolution === minResolution || found.length >= softLimit){
  //           outer.end()
  //         }
  //         else {
  //           resolution--
  //           read(resolution)
  //         }
  //       }
  //     }
  //     ks.pipe(inner).pipe(outer, { end: false })
  //     outer.on('end', ks.destroy.bind(ks))
  //   })
  // }
  // 
  // process.nextTick(function () {
  //   read(resolution)
  // })
  //
  // return outer
}

geometer.prototype.stream = function(pos, opts){
  var kvToPoint = this.kvToPoint
  var kvToPointStream = through(function({key, value}){
    this.queue(kvToPoint(key, value))
  })

  var resultStream = this.createSearchStream(pos, opts).pipe(kvToPointStream)

  resultStream.toArray = function(cb){
    resultStream.pipe(es.writeArray(function(err, results){
      //@TODO sorting
      // var sorted = results.sort(function(a, b){
      //   if(a.distance < b.distance) return -1
      //   if(a.distance > b.distance) return 1
      //   return 0
      // })
      cb(null, results)
    }))
  }

  return resultStream
}

function createPointKey(ref, normalAbTuple, z){
  return ['p', encode(normalAbTuple), z, ref].join('~')
}

function createRefKey(ref){
  return ['r', ref].join('~')
}
