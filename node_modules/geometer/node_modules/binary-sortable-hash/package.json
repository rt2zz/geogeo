{
  "name": "binary-sortable-hash",
  "description": "Hash an array of numbers into a sortable(ish) binary number.",
  "version": "0.0.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/rt2zz/binary-sortable-hash.git"
  },
  "homepage": "git://github.com/rt2zz/binary-sortable-hash.git",
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js"
  },
  "dependencies": {},
  "devDependencies": {
    "ben": "0.0.0",
    "tape": "~1.0.4"
  },
  "keywords": [
    "hash",
    "geohash",
    "sortable"
  ],
  "license": "MIT",
  "readme": "# binary-sortable-hash\n\nHash arrays of numbers into a binary string from which you can reconstruct the\noriginal values, with configurable precision loss. The generated hashes\n**sort well**, so similar input values cause large shared prefixes in hashes. (as seen in [geohashing](http://en.wikipedia.org/wiki/Geohash))\n\n```js\nsortable.encode([0]) === '011111111111111111111111111111111111111111111111111111111111';\nsortable.decode(011111111111111111111111111111111111111111111111111111111111, 1) === -8.673617379884035e-17\nsortable.encode([10, 11, -10]) === '110001001001110110011001100100001011100110001001100110011011';\n```\n\n[![build status](https://secure.travis-ci.org/rt2zz/binary-sortable-hash.png)](http://travis-ci.org/rt2zz/binary-sortable-hash)\n\n## Usage\n\nHash a lat/lon array representing RÃ¶cken Germany\n\n`[10, -10, 10]` and then restore it, using different\nhash sizes.\n\n```js\nvar sortable = require('sortable-hash');\n\nvar rocken = {lat: 51.2408, lon: 12.1161}\n//normalize scalars to +-100\nvar normalized = [100*rocken.lat/180, 100*rocken.lon/90]\n\nvar hash = sortable.encode(normalized)\n// => '110010010010000100101111010001010001001110011100001100111111'\n\nsortable.decode(hash, 2);\n// => [ 51.24080015346408, 12.116099959239364 ]\n\nvar lowerFidelityHash = sortable.encode(normalized, 10)\n// => 1100100100\nsortable.decode(lowerFidelityHash, 2)\n// => [50.625, 14.0625]\n\nvar hexadecimalHash = parseInt(hash, 2).toString(16)\n// => c9212f45139c300 (limited precision beyond 53bits)\n```\n\n**note:** If you need precision when converting integers above 53 bits consider using [bigint](https://github.com/substack/node-bigint)\n\n## API\n\n### sortable.encode(values[, options])\n\nHash the array `values`, which may only contain Numbers in the range of\n`[-100, 100]`.\n\n`options` can either be an object with these possible keys:\n\n* `precision`: Number of bits (read: length) of the resulting binary hash\n\nor a Number, in which case it sets `options.precision`.\n\n### sortable.decode(string, options)\n\nDecode `string` into an Array of Numbers.\n\n`options` can either be an object with these possible keys:\n\n* `num`: number of elements initially passed to `hash.encode`. (required)\n\nOr a Number, in which case it sets `options.num`\n\n## Installation\n\nWith [npm](http://npmjs.org) do:\n\n```bash\n$ npm install binary-sortable-hash\n```\n\n## Kudos\n\nThis is the idea of [geohashes](http://en.wikipedia.org/wiki/Geohash)\ngeneralized for use with all numeric data and numbers of input fields.\n\nbinary-sortable-hash is a derivative of the awesome [sortable-hash](https://github.com/juliangruber/sortable-hash) by @juliangrubber\n",
  "readmeFilename": "README.md",
  "gitHead": "8a6334ff7cd090b19a99f1114f379c3633fe457a",
  "bugs": {
    "url": "https://github.com/rt2zz/binary-sortable-hash/issues"
  },
  "_id": "binary-sortable-hash@0.0.1",
  "_shasum": "62d574de57909805d49731c29443c6918fda618b",
  "_from": "binary-sortable-hash@*"
}
