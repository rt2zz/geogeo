'use strict';

exports.__esModule = true;
exports.remotesMiddleware = remotesMiddleware;
exports.createRemote = createRemote;
exports.remoteActionMap = remoteActionMap;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _invariant = require('invariant');

//@TODO need to figure out how this plays with action replay and other redux enhancers

var _invariant2 = _interopRequireDefault(_invariant);

function remotesMiddleware(remote) {
  return function (_ref) {
    var dispatch = _ref.dispatch;
    var getState = _ref.getState;

    return function (next) {
      return function (action) {
        remote(action, dispatch, getState);
        return next(action);
      };
    };
  };
}

function createRemote(remotes, config) {
  var finalRemotes = _lodash2['default'].pick(remotes, function (val) {
    return typeof val === 'function';
  });
  config = config || {};

  var contracts = [];
  var archive = [];

  window.logRemotes = function () {
    console.log('Contracts:', contracts, 'Archive:', archive);
  };

  return function combinationRemote(action, dispatch, getState) {

    var keys = _lodash2['default'].keys(finalRemotes);
    var contract = {
      unresolved: keys,
      resolved: [],
      dispatches: [],
      action: action
    };

    contracts.push(contract);

    _lodash2['default'].forEach(finalRemotes, function (remote, key) {
      var handled = remote({ action: action, getState: getState, dispatch: subdispatch, finish: finish });
      //if remote explicitly returns false, assume noop
      if (handled === false) {
        noopResolve(key);
      }

      function finish(finalAction) {
        if (typeof finalAction === 'object') {
          subdispatch(finalAction);
        }
        resolve(key);
      }
    });

    function subdispatch(subaction) {
      contract.dispatches.push(subaction);
      dispatch(subaction);
    }

    function resolve(key) {
      contract.resolved.push(key);
      noopResolve(key);
    }

    //same as above but do not add to resolved list
    function noopResolve(key) {
      _invariant2['default'](contract.unresolved.indexOf(key) !== -1, 'Cannot resolve twice for remote: ' + key + ' for Action: ' + action.type + '. You either called finish() twice or returned false and called finish()');
      contract.unresolved = _lodash2['default'].without(contract.unresolved, key);
      if (contract.unresolved.length === 0) {
        completeContract();
      }
    }

    function completeContract() {
      contracts = _lodash2['default'].without(contracts, contract);
      //only process if something was handled
      if (contract.resolved.length > 0) {
        archive.unshift(contract);
        archive = archive.slice(0, 1000);
        if (config.log === true) {
          var groupable = typeof console.groupCollapsed === 'function';

          if (groupable) {
            console.groupCollapsed('%c ' + action.type, 'background: #c9f2ac');
          }
          console.log('resolved %i remotes', contract.resolved.length, contract.resolved);
          console.log('dispatched %i child actions', contract.dispatches.length, _lodash2['default'].pluck(contract.dispatches, 'type'));
          console.log('%i contracts outstanding', contracts.length, _lodash2['default'].map(contracts, function (contract) {
            return contract.action.type;
          }));

          if (groupable) {
            console.groupCollapsed('more details');
            console.log("completed contract: %0", contract);
            console.log("outstanding contracts: %0", contracts);
            console.groupEnd();
          }

          if (groupable) {
            console.groupEnd();
          }
        }
      }
    }
  };
}

function remoteActionMap(map) {
  return function (api) {
    if (!map[api.action.type]) {
      return false;
    }
    map[api.action.type](api);
    return true;
  };
}