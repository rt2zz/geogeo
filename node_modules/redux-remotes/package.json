{
  "name": "redux-remotes",
  "version": "0.1.5",
  "description": "Remotes",
  "main": "lib/index.js",
  "scripts": {
    "clean": "rimraf lib dist",
    "build": "babel src --out-dir lib",
    "build:watch": "watch 'npm run build' ./src",
    "todo:test": "NODE_ENV=test mocha --compilers js:babel/register --recursive",
    "todo:test:watch": "NODE_ENV=test mocha --compilers js:babel/register --recursive --watch",
    "test:cov": "babel-node ./node_modules/.bin/isparta cover ./node_modules/.bin/_mocha -- --recursive",
    "prepublish": "npm run clean && npm run build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rt2zz/redux-remotes.git"
  },
  "homepage": "https://github.com/rt2zz/redux-remotes",
  "keywords": [
    "redux",
    "middleware",
    "redux-middleware",
    "flux"
  ],
  "author": {
    "name": "Zack Story",
    "email": "zack@root-two.com"
  },
  "license": "MIT",
  "devDependencies": {
    "babel": "^5.6.14",
    "babel-core": "^5.6.15",
    "babel-eslint": "^3.1.20"
  },
  "dependencies": {
    "invariant": "^2.1.0",
    "lodash": "^3.10.0"
  },
  "readme": "# Redux Remotes\nTrigger remote interactions (e.g. async actions) via dispatch.  \n\nRemotes provides a standard, predicatable, semi-declarative API for handling remote interactions. It is similar to using redux-thunk, except instead of dispatching a function, you dispatch a \"command\" action which is then handled by a remote. There are potentially a few benefits to this approach:\n* \"Command actions\" are serializable (as opposed to action creator invocation which is not)\n* Robust and standardized logging\n* See all dispatches that originated from within a remote-action\n* Potential to archive and replay all remote interactions\n* See all oustanding \"contracts\" at any point in time, which can be really useful for long running remote interactions like geolocation.\n* Apply a remote interaction to multiple or all action types (e.g. remote logging)\n* Apply multiple remote interactions to one source action\n\nAdditionally because the structure of remotes mirrors that of reducers, the mental model is light and easy to integrate within an existing redux application.\n\n**Warning** this is an early experiment.\n\nNot necessarily redux specific, but that is the target architecture.\n\n## What does it look like?\nRemotes works as follows:  \n1. Compose multiple `remotes` into a single `remote` function (just like you do with reducers  \n2. Install the middleware. The middleware sends every action to the registered remote before passing it along.   \n3. A contract is created for every action that one more remotes handles.  \n4. Each remote calls finish() when it is done operating on an action.  \n\nTo get a better idea of what this looks like, see the console logging upon contract completion:\n<hr />\n<img style=\"border:2px solid #aaaaaa;\" src=\"https://raw.githubusercontent.com/rt2zz/redux-remotes/master/examples/log.png\" />\n\n## Usage\n```js\nimport { createRemote, remotesMiddleware } from 'redux-remotes'\nimport * as remotes from '../remotes'\n\nconst remote = createRemote(remotes, {log: true})\nconst remoteMW = remotesMiddleware(remote)\nconst createStoreWithMiddleware = applyMiddleware(remoteMW)(createStore)\n```\nin reducers/someReducer.js\n```js\nimport { INCREMENT } from '../constants/ActionTypes'\n\nexport default function account(action, finish, dispatch) {\n  switch (action.type) {\n\n  case INCREMENT:\n    //call finish when done operating so the contract can be closed.\n    setTimeout(finish, 1000)\n    //return true indicates this remote is going to operate, and the contract should wait for response\n    return true\n\n  default:\n    //return false if no operation\n    return false\n  }\n}\n```\n\n## Use Cases\nRestful Resource\n```js\nexport default function profile(action, finish, dispatch) {\n  switch (action.type) {\n\n  case PROFILE_CREATE:\n    let profile = {...action.data, timestamp: Date.now()}\n    profilePending(profile)\n    apiClient.createProfile(profile, (err) => {\n      if(err){ profileFail(profile) }\n      else{ profileSuccess(profile) }\n      finish()\n    })\n    return true\n\n  default:\n    return false\n  }\n\n  function profilePending(profile){\n    dispatch({ type: PROFILE_CREATE_PENDING, profile: profile})\n  }\n  function profileFail(profile){\n    dispatch({ type: PROFILE_CREATE_FAIL, profile: profile})\n  }\n  function profileSuccess(profile){\n    dispatch({ type: PROFILE_CREATE_SUCCESS, profile: profile })\n  }\n}\n```\n\nOther times remotes may not need to report their status as actions. For example a remote action logger:\n```js\nexport default function remoteLogger(action, finish, dispatch) {\n  remoteLog(action, () => {\n    finish()\n  })\n  return true\n}\n```\n\nOr a remote stream\n```js\nexport default function alertPipe(action, finish, dispatch) {\n  switch (action.type) {\n\n  let unsubscribe = null\n\n  case SUBSCRIBE_TO_ALERTS:\n    listener = rethinkDBListener((alert) => {\n      dispatch({\n        type: 'ALERT',\n        alert: alert,\n      })\n    })\n    unsubscribe = () => {\n      listener.destroy()\n      finish()\n    }\n    //finish is never called, meaning this will always show\n    return true\n\n  case UNSUBSCRIBE_TO_ALERTS:\n    unsubscribe && unsubscribe()\n    finish()\n    return true\n\n  default:\n    return false\n}\n```\n\n## Uncertainties\nThis may need some tweaking to play well with store enhancers like redux-devtools. Further testing and experimentation is needed.\n",
  "readmeFilename": "README.md",
  "gitHead": "e164426b6a5c22bca40e0a5d814ac700a225b434",
  "bugs": {
    "url": "https://github.com/rt2zz/redux-remotes/issues"
  },
  "_id": "redux-remotes@0.1.5",
  "_shasum": "9e11d0e1d688e24db023b358e21d77bcf620b058",
  "_from": "redux-remotes@*"
}
